import java.util.*;
import java.util.stream.Collectors;

/**
 * This class represents a grammar. It is used to represent a grammar from a BNF file that denotes the  and to check if a given
 * string is in the language of the grammar. The grammar is represented as a Map of non-terminal symbols
 * that stores a structure that the grammar recognizes. Note that the word Rule is interchangeable with 
 * the raw BNF lines passed to the constructor. And Rule can also be used to refer to list of the structures
 * associated to a non-terminal symbol.
 * 
 * A gramatical correct sentence is a sequence of symbols that can be generated and recognized by the grammar.
 * A symbol is a recognizable string by the Grammar that can be a terminal or non-terminal.
 */
public class Grammar {
    /** The list of nonTerminals present in the Grammar. each nonTerminal is associated with list of
     * rules. */
    Map<String, List<List<String>>> nonTerminals;

    /**
     * Constructs a Grammar from the given list of BNF rules. Note that the BNF list passed is copied.
     * @param bnf the list of raw BNF rules read from a file.
     */
    public Grammar(List<String> bnf) {
        if (bnf == null) {
            throw new IllegalArgumentException("Grammar must be non-null.");
        } else if (bnf.isEmpty()) {
            throw new IllegalArgumentException("Grammar must be non-empty.");
        }
        // creating a rule parser throws and exception if the bnf list of raw rules: 
        //     contains a non-terminal empty symbol rule
        //     contains a non-terminal with no rules
        initGrammar(new RuleParser(bnf));
    }

    /**
     * Constructs a Grammar from the given RuleParser. 
     * @param ruleParser the RuleParser passed that collects the data in the correct format.
     */
    protected void initGrammar(RuleParser parser) {
        nonTerminals = parser.getRules().stream()
            .collect(Collectors.toMap(
                TuppleRule::getNonTerminalSymbol,
                TuppleRule::getRules,
                // if two rules have the same non-terminal symbol, then union the rules of the non-terminal.
                (a, b) -> { 
                    a.addAll(b);
                    return a;
                },
                TreeMap::new // collect the rules in a TreeMap to atomaticaly sort the non-terminals strings.
            ));
    }

    /**
     * Checks if the given string is a non-terminal symbol recognizable by the grammar.
     * @param symbol the symbol to check.
     * @return
     */
    public boolean isNonTerminal(String symbol) {
        if (symbol == null) {
            throw new IllegalArgumentException("Symbol must be non-null.");
        } else if (symbol.length() == 0) {
            throw new IllegalArgumentException("Symbol must be non-empty.");
        }
        return nonTerminals.get(symbol) != null;
    }

    /**
     * Creates a string representation of a logical set of Symbols present in the grammar.
     * 
     * Safety: This method might end in a infinite loop if a non-terminal contains itself within its own rules.
     * @param nonTerminalSymbol
     * @return
     */
    public String getRandom(String nonTerminalSymbol) {
        List<String> rule = getRandomRule(nonTerminalSymbol);
        StringBuilder out = new StringBuilder();
        for (String symbol : rule) {
            // if the symbol is a non-terminal, get a random gramatical sentence from it without adding a space
            if (isNonTerminal(symbol)) {
                out.append(getRandom(symbol));
            } else {
                out.append(symbol).append(" ");
            }
        }
        return out.toString();
    }
    
    /**
     * Returns a random rule from the list of rules associated to the given non-terminal symbol.
     * @param nonTerminalSymbol the seed non-terminal symbol to generate a random grammatical correct sentence.
     * @return
     */
    protected List<String> getRandomRule(String nonTerminalSymbol) {
        List<List<String>> rules = this.nonTerminals.get(nonTerminalSymbol);
        return rules.get(new Random().nextInt(rules.size()));
    }

    /**
     * Creates a List of size number of random grammatical correct sentences generated by getRandom(String).
     * 
     * @param number the number of sentences to generate and also the size of the returned list.
     * @param nonTerminal the seed non-terminal symbol to start the generation.
     * @return
     */
    public List<String> getRandom(int number, String nonTerminal) {
        List<String> out = new ArrayList<>();
        for (int i = 0; i < number; i++) {
            out.add(getRandom(nonTerminal));
        }
        return out;
    }
    
    /**
     * Returns a string representation of set of non-terminal symbols present in the grammar.
     * the list is sorted by alphabetical order due the use of a TreeMap to store the non-terminals symbol strings.
     */
    @Override
    public String toString() {
        return nonTerminals.keySet().toString();
    }
}
